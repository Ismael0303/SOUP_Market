ROADMAP - Protocolo de Actualizaciones y Plugins & Plugins 'Actualización Panadería' y 'Actualización Discográfica' 
Fecha: 8 de Julio de 2025 
Proyecto: SOUP Emprendimientos - Full Stack (FastAPI + React) 
Mantenedor: Asistente AI 
ÍNDICE 
1. Introducción para Cursor
 2. Capítulo 3: Protocolo de Actualizaciones y Plugins
 3. Capítulo 4: Plugin Específico: "Actualización Panadería"
 4. Capítulo 5: Plugin Específico: "Actualización Discográfica"
 5. Instrucciones de Implementación para Cursor
 1. Introducción para Cursor 
Este documento integra la definición del Protocolo de Actualizaciones y Plugins 
con el detalle de dos plugins específicos a desarrollar bajo este protocolo: la 
"Actualización Panadería" (adaptada retroactivamente) y la "Actualización 
Discográfica". Este documento servirá como tu referencia principal para entender la 
arquitectura modular y las funcionalidades a implementar para estos plugins. 
2. Capítulo 3: Protocolo de Actualizaciones y Plugins 
Prioridad: ALTA (Definición de arquitectura modular) 
Fecha de Inicio Estimada: Inmediato (Conceptualización y preparación) 
Objetivo: Establecer un protocolo de desarrollo y despliegue para funcionalidades 
específicas de negocio (plugins), asegurando modularidad, reusabilidad y un modelo de 
monetización flexible. 
Visión General 
SOUP Market evolucionará hacia una plataforma modular donde las funcionalidades 
avanzadas y específicas para cada tipo de negocio (Panadería, Sello Discográfico, 
Estudio de Arquitectura, etc.) se ofrecerán como "plugins" independientes. Estos 
plugins serán activables por usuarios premium, permitiendo una personalización del 
servicio y un modelo de negocio escalable basado en suscripciones mensuales por 
plugin. 
Principios Clave del Protocolo de Plugins 
1. Modularidad e Independencia: 
○ Cada "actualización" o conjunto de funcionalidades para un tipo de negocio 
específico (ej., "Módulo Panadería", "Módulo Sello Discográfico") se diseñará 
como un plugin independiente. 
○ Esto significa que el código, los modelos de datos (si son específicos del 
plugin), los esquemas, las rutas y los componentes de frontend asociados a 
un plugin deben estar lo más encapsulados posible. 
○ Un plugin puede depender de las funcionalidades "core" de SOUP (gestión 
de productos, insumos, usuarios, negocios), pero no debe crear 
dependencias circulares con otros plugins. 
2. Activación por Usuarios Premium: 
○ Los usuarios con un tipo_tier adecuado (ej., microemprendimiento o 
freelancer con una suscripción activa) tendrán la opción de activar los 
plugins desde su dashboard. 
○ En producción, esta activación se realizará a través de un "Marketplace de 
Plugins" dentro de la aplicación, donde los usuarios podrán ver, seleccionar y 
suscribirse a los plugins que necesiten. 
○ Pseudocódigo de Alto Nivel (Activación): 
// Backend: Modelo Usuario (models.py) 
class Usuario(Base): 
    # ... campos existentes ... 
    plugins_activos: Mapped[Optional[List[str]]] = 
mapped_column(ARRAY(String), nullable=True, default=list) 
    # Ejemplo: ["panaderia_plugin", "sello_discografico_plugin"] 
    # Este campo se actualizará cuando el usuario active/desactive un plugin. 
 
// Backend: Router de Plugins (nuevo: routers/plugin_router.py) 
FUNCION activate_plugin(db: Session, user_id: UUID, plugin_name: str): 
    usuario = crud_user.get_user_by_id(db, user_id) 
    SI NOT usuario.es_premium() ENTONCES ERROR "Requiere suscripción 
premium" 
    SI plugin_name NO ESTA EN usuario.plugins_activos: 
        usuario.plugins_activos.append(plugin_name) 
        db.add(usuario) 
        db.commit() 
        RETORNAR Exito 
 
// Frontend: Dashboard / Marketplace de Plugins (Componente: 
PluginMarketplace.js - NUEVO) 
FUNCION handleActivatePlugin(pluginName): 
    SI usuario.tieneSuscripcionPremium(): 
        LLAMAR backend.pluginApi.activatePlugin(pluginName) 
        MOSTRAR mensajeExito("Plugin activado. Recarga la página para ver los 
cambios.") 
    SINO: 
        MOSTRAR mensajeError("Necesitas una suscripción premium para 
activar plugins.") 
 
// Frontend: Lógica de Renderizado Condicional 
FUNCION renderDashboard(): 
    SI usuario.plugins_activos.INCLUYE("panaderia_plugin"): 
        RENDERIZAR ComponentePanaderiaDashboard() 
    SI usuario.plugins_activos.INCLUYE("sello_discografico_plugin"): 
        RENDERIZAR ComponenteSelloDiscograficoDashboard() 
    // ... y así sucesivamente para rutas y elementos de UI 
 
3. Precios Mensuales Específicos: 
○ Cada plugin tendrá un precio mensual asociado, determinado por su 
complejidad y el valor que aporta. 
○ Esto requerirá un nuevo modelo/tabla Plugin en el backend para almacenar 
nombre, descripcion, precio_mensual, activa_por_defecto (para plugins 
básicos incluidos en el tier). 
○ La gestión de pagos y suscripciones se dejará para un capítulo posterior. 
4. Principio "Don't Repeat Yourself" (DRY): 
○ Elementos Compartidos: 
■ Modelos Core: Usuario, Negocio, Producto, Insumo y sus relaciones 
(ProductoInsumo) son la base compartida. 
■ CRUD Core: Las operaciones básicas de creación, lectura, actualización 
y eliminación para los modelos core se reutilizarán. 
■ Autenticación y Autorización: El sistema de JWT y get_current_user es 
transversal. 
■ Componentes UI Básicos: Button, Input, Card, Select, etc., de Shadcn/ui 
y Tailwind CSS. 
■ Estructura de API: Convenciones de endpoints, manejo de errores. 
○ Implementación: 
■ Las funcionalidades específicas de un plugin se construirán sobre esta 
base core. 
■ Por ejemplo, el "Módulo Panadería" reutiliza Producto e Insumo para 
gestionar el Chipá, y el "Módulo Sello Discográfico" reutiliza Producto 
para discos y merch. Los nuevos campos o lógicas específicas se 
añadirán de forma que no rompan la funcionalidad core. 
■ Esto puede implicar: 
■ Extender enums existentes (ej., ProductType para tipos de 
discos/merch). 
■ Añadir campos opcionales a modelos core que solo se usan si un 
plugin está activo (ej., stock_terminado en Producto). 
■ Crear nuevos modelos y tablas solo si la entidad es completamente 
específica de un plugin (ej., ContratoBanda para el sello discográfico). 
■ Componentes de React que se renderizan condicionalmente según 
los plugins_activos del usuario. 
5. Activación en Desarrollo vs. Producción: 
○ Desarrollo: Para facilitar el desarrollo y las pruebas, los plugins se podrán 
"activar" (simular la suscripción) directamente desde el dashboard del 
desarrollador o mediante variables de entorno/configuración local. Esto 
permitirá probar la interfaz y la lógica sin necesidad de un marketplace de 
pagos. 
○ Producción: En el entorno de producción, la activación se realizará a través 
de un Marketplace de Plugins dentro de la aplicación. Este marketplace 
gestionará las suscripciones, los pagos y actualizará el estado 
plugins_activos del usuario en la base de datos. 
Próximos Pasos del Capítulo 3 (Prioridad Alta) 
1. Añadir Campo plugins_activos al Modelo Usuario en Backend: 
○ Modificar backend/app/models.py para incluir plugins_activos: 
Mapped[Optional[List[str]]] = mapped_column(ARRAY(String), nullable=True, 
default=list). 
○ Crear migración para añadir este campo. 
○ Actualizar backend/app/schemas.py para incluirlo en UsuarioResponse (solo 
lectura) y quizás en UsuarioUpdate para fines administrativos/testing. 
2. Crear un Nuevo Router y CRUD para la Gestión de Plugins (Backend): 
○ backend/app/routers/plugin_router.py con endpoints para GET /plugins (listar 
plugins disponibles), POST /plugins/activate y POST /plugins/deactivate. 
○ backend/app/crud/plugin.py con la lógica para actualizar el campo 
plugins_activos del usuario. 
3. Implementar Lógica de Renderizado Condicional en Frontend: 
○ Modificar DashboardScreen.js y App.js (o un componente de layout superior) 
para leer user.plugins_activos y renderizar condicionalmente las rutas y 
componentes específicos de cada plugin. 
4. Diseñar la Base del Marketplace de Plugins (Frontend): 
○ Crear una pantalla frontend/src/screens/PluginMarketplaceScreen.js que liste 
los plugins disponibles (obtenidos del backend) y tenga botones de 
"Activar"/"Desactivar". 
Funciones Avanzadas (Capítulos Posteriores) 
● Integración con Pasarela de Pagos: Para gestionar las suscripciones a plugins. 
● Módulo de Gestión de Suscripciones: Para que los usuarios puedan ver y 
gestionar sus plugins activos y facturación. 
● Versionado de Plugins: Para gestionar actualizaciones de plugins de forma 
independiente. 
● Sistema de Notificaciones: Para informar a los usuarios sobre nuevos plugins o 
actualizaciones. 
3. Capítulo 4: Plugin Específico: "Actualización Panadería" 
Prioridad: ALTA (Primer plugin específico a adaptar) 
Fecha de Inicio Estimada: Tras la finalización del Capítulo 3 
Objetivo: Adaptar las funcionalidades clave de gestión de ventas en local, inventario y 
producción para una panadería (ej. Panadería Ñiam) como un plugin independiente dentro 
del protocolo de SOUP Market. 
Visión General 
El plugin "Actualización Panadería" permitirá a negocios como "Panadería Ñiam" 
integrar SOUP Market como su sistema de Punto de Venta (POS) interno para 
registrar transacciones, gestionar inventario en tiempo real y proporcionar análisis 
financiero. La venta en local físico es la prioridad, con pedidos online como un canal 
secundario, pero también gestionado por SOUP. 
Roles y Funcionalidades Clave 
1.    
Trabajador de Atención al Cliente (Usa SOUP Dashboard - Punto de Venta 
Principal) 
Funciones Prioritarias: 
● Registro de Ventas en Local (SOUP: ManageProductsScreen / Nuevo 
Módulo POS): 
○ Pseudocódigo de Alto Nivel: 
// Frontend: Pantalla de Venta en Local (POS) 
// Componente: SalePointScreen.js (NUEVO) 
// Ubicación: frontend/src/screens/SalePointScreen.js 
 
FUNCION renderSalePointScreen(): 
    ESTADO productosSeleccionados = [] 
    ESTADO totalVenta = 0 
 
    FUNCION handleProductSelection(productoId, cantidad): 
        // Lógica para añadir/actualizar producto en productosSeleccionados 
        // Actualizar totalVenta 
        LLAMAR updateProductInventory(productoId, -cantidad) // Descontar 
inmediatamente del inventario 
 
    FUNCION handleCompleteSale(): 
        PARA CADA producto en productosSeleccionados: 
            LLAMAR backend.productApi.recordSale(producto.id, 
producto.cantidad, usuarioLogueado.id) 
        MOSTRAR mensajeExito("Venta registrada y stock actualizado.") 
        LIMPIAR productosSeleccionados, totalVenta 
 
// Backend: crud/product.py 
FUNCION record_sale(db: Session, product_id: UUID, quantity_sold: float, 
user_id: UUID): 
    db_product = crud_product.get_product_by_id(db, product_id) 
    SI NOT db_product ENTONCES ERROR "Producto no encontrado" 
    SI db_product.propietario_id != user_id ENTONCES ERROR "No autorizado" 
 
    // Descontar del inventario de productos terminados (campo futuro: 
stock_terminado) 
    // Para este capítulo, la 'cantidad_disponible' de insumos se reducirá al 
vender el producto. 
    // Se asume que el 'stock_terminado' se implementará en un capítulo 
posterior. 
 
    // Registrar la venta (tabla futura: Ventas/Transacciones) 
    // Esto impactará en ventas_completadas y total_ingresos 
 
    // Actualizar insumos asociados al producto 
    PARA CADA insumo_asociado en db_product.insumos_asociados: 
        insumo = crud_insumo.get_insumo_by_id(db, 
insumo_asociado.insumo_id) 
        SI insumo ENTONCES 
            insumo.cantidad_disponible -= insumo_asociado.cantidad_necesaria * 
quantity_sold 
            db.add(insumo) // Marcar para actualización 
 
    db.commit() 
    db.refresh(db_product) 
 
○ Integración al Código Existente (Capítulo 4 - Prioridad Alta): 
■ Frontend: Se creará una nueva pantalla SalePointScreen.js en 
frontend/src/screens/. Se integrará al App.js con una nueva ruta 
protegida (ej., /dashboard/pos). Esta ruta y el componente se 
renderizarán condicionalmente si el plugin panaderia_plugin está activo. 
■ Backend: La lógica de record_sale se integrará en 
backend/app/crud/product.py (o en un nuevo CRUD de Transaccion si se 
crea). La reducción de insumos se realizará en esta lógica. Se necesitará 
un nuevo endpoint en backend/app/routers/product_router.py (o un 
nuevo sales_router.py) para POST /products/{product_id}/record_sale. 
● Consulta de Inventario de Productos (SOUP: ManageProductsScreen): 
○ Pseudocódigo de Alto Nivel: 
// Frontend: ManageProductsScreen.js 
FUNCION fetchProducts(): 
    productos = LLAMAR productApi.getAllMyProducts() 
    MOSTRAR productos.map(p => p.nombre, p.stock_terminado) // 
stock_terminado es un campo futuro 
 
○ Integración al Código Existente (Capítulo 4 - Prioridad Alta): 
■ Frontend: Ya existe ManageProductsScreen.js. Se actualizará para 
mostrar un campo stock_terminado (futuro). 
■ Backend: El modelo Producto en backend/app/models.py necesitará un 
campo stock_terminado: Mapped[Optional[float]] = 
mapped_column(Float, nullable=True). La lógica para actualizar este 
stock al producir o vender se añadiría en crud/product.py. 
● Recepción y Gestión de Pedidos Online (Módulo Encargos - Funcionalidad 
Futura): 
○ Pseudocódigo de Alto Nivel: 
// Frontend: ManageOrdersScreen.js (NUEVO - Capítulo posterior) 
FUNCION fetchOrders(): 
pedidos = LLAMAR orderApi.getAllMyOrders() 
MOSTRAR pedidos.map(p => p.cliente, p.estado, p.productos) 
FUNCION updateOrderStatus(orderId, newStatus): 
LLAMAR orderApi.updateOrder(orderId, { estado: newStatus }) 
MOSTRAR mensajeExito("Estado actualizado.") 
○ Integración al Código Existente: Se dejará para un capítulo posterior. 
Implicaría nuevos modelos (Pedido, ItemPedido), esquemas, CRUDs y routers, 
que también se activarían con el plugin de panadería. 
2.    
Cocinero / Productor de Insumos (Usa SOUP Dashboard) 
Funciones Prioritarias: 
● Gestión de Insumos (SOUP: ManageInsumosScreen, CreateInsumoScreen, 
EditInsumoScreen): 
○ Pseudocódigo de Alto Nivel: 
// Frontend: ManageInsumosScreen.js 
FUNCION fetchInsumos(): 
insumos = LLAMAR insumoApi.getAllMyInsumos() 
MOSTRAR insumos.map(i => i.nombre, i.cantidad_disponible, 
i.costo_unitario_compra) 
// Frontend: CreateInsumoScreen.js / EditInsumoScreen.js 
FUNCION handleSubmitCreateInsumo(formData): 
LLAMAR insumoApi.createInsumo(formData) 
MOSTRAR mensajeExito("Insumo creado.") 
FUNCION handleSubmitUpdateInsumo(insumoId, formData): 
LLAMAR insumoApi.updateInsumo(insumoId, formData) 
    MOSTRAR mensajeExito("Insumo actualizado.") 
 
○ Integración al Código Existente: Estas pantallas ya existen y funcionan. 
Solo se enfatizará su uso para el workflow. 
● Gestión de Productos (SOUP: ManageProductsScreen, 
CreateProductScreen, EditProductScreen): 
○ Definir Recetas (Asociación Insumos): 
■ Pseudocódigo de Alto Nivel: 
// Frontend: CreateProductScreen.js / EditProductScreen.js 
FUNCION handleAddInsumoToProduct(insumoId, cantidadNecesaria): 
    // Añadir a selectedInsumos 
 
FUNCION handleSubmitProduct(formData): 
    // formData.insumos_asociados contiene [{insumo_id, 
cantidad_necesaria}] 
    // LLAMAR productApi.createProduct(formData) o 
productApi.updateProduct(productId, formData) 
 
■ Integración al Código Existente: Ya implementado en 
CreateProductScreen.js y EditProductScreen.js. 
○ Ver Costos de Producción (COGS): 
■ Pseudocódigo de Alto Nivel: 
// Frontend: CreateProductScreen.js / EditProductScreen.js 
// useEffect para recalcular COGS en frontend 
FUNCION calculateCogs(selectedInsumos, availableInsumos): 
    totalCogs = 0 
    PARA CADA item en selectedInsumos: 
        insumo = buscar insumo en availableInsumos por item.insumo_id 
        SI insumo ENTONCES 
            totalCogs += parseFloat(item.cantidad_necesaria) * 
insumo.costo_unitario_compra 
    RETORNAR totalCogs 
 
// Backend: crud/product.py 
FUNCION _calculate_product_costs_and_prices(db, db_product): 
    // Lógica de cálculo de total_cogs basada en 
db_product.insumos_asociados 
    db_product.cogs = total_cogs 
 
■ Integración al Código Existente: Ya implementado en backend 
(crud/product.py) y frontend (CreateProductScreen.js, 
EditProductScreen.js). 
○ Ajustar Precios y Márgenes: 
■ Pseudocódigo de Alto Nivel: 
// Frontend: CreateProductScreen.js / EditProductScreen.js 
// Campos de input para precio_venta y margen_ganancia_sugerido 
// useEffect para recalcular precio_sugerido y margen_ganancia_real en 
frontend 
FUNCION calculateSuggestedPrice(cogs, margen): 
    SI cogs y margen ENTONCES 
        RETORNAR cogs * (1 + margen / 100) 
    RETORNAR NULL 
 
FUNCION calculateRealMargin(cogs, precioVenta): 
    SI cogs > 0 y precioVenta ENTONCES 
        RETORNAR ((precioVenta - cogs) / cogs) * 100 
    RETORNAR NULL 
 
// Backend: crud/product.py y routers/product_router.py 
// Lógica de cálculo en _calculate_product_costs_and_prices y 
_calculate_margen_ganancia_real 
 
■ Integración al Código Existente: Ya implementado en backend y 
frontend. 
3.   Dueños / Managers (Usa SOUP Dashboard) 
Funciones Prioritarias: 
● Visión General del Negocio (SOUP: DashboardScreen, 
ManageBusinessesScreen): 
○ Pseudocódigo de Alto Nivel: 
// Frontend: DashboardScreen.js 
FUNCION fetchDashboardData(): 
    usuario = LLAMAR authApi.getProfile() 
    negocios = LLAMAR businessApi.getAllMyBusinesses() 
    productos = LLAMAR productApi.getAllMyProducts() 
    // Mostrar resumen de ventas_completadas, calificacion_promedio (futuro) 
○ Integración al Código Existente: DashboardScreen.js y 
ManageBusinessesScreen.js ya existen. Se actualizarán para mostrar 
ventas_completadas y calificacion_promedio (futuras). 
● Gestión Financiera (Módulo de Reportes - Funcionalidad Futura): 
○ Pseudocódigo de Alto Nivel: 
// Frontend: ReportsScreen.js (NUEVO - Capítulo posterior) 
FUNCION fetchSalesReports(periodo): 
reporte = LLAMAR salesApi.getSalesReport(periodo) // Nueva API de 
reportes 
MOSTRAR reporte.ingresosTotales, reporte.egresosInsumos, 
reporte.margenNeto 
○ Integración al Código Existente: Se dejará para un capítulo posterior. 
Implicaría nuevos modelos (Transaccion, Reporte), esquemas, CRUDs y 
routers, que también se activarían con el plugin de panadería. 
● Análisis de Rentabilidad: 
○ Pseudocódigo de Alto Nivel: 
// Frontend: ManageProductsScreen.js (para ver por producto) 
// O ReportsScreen.js (para ver agregados) 
FUNCION displayProfitability(product): 
MOSTRAR product.cogs, product.precio_venta, 
product.margen_ganancia_real 
○ Integración al Código Existente: Ya visible en EditProductScreen.js. Se 
extenderá a ManageProductsScreen.js en un paso posterior de este capítulo. 
4.   Cliente (Interacción Principalmente Física / Opcional Online) 
Funciones Prioritarias: 
● Compra en Local Físico: 
○ Pseudocódigo de Alto Nivel: 
// Proceso físico en el local, registrado por el Trabajador de Atención al 
Cliente en SOUP. 
// No hay interacción directa del cliente con SOUP en este punto para la venta 
física. 
○ Integración al Código Existente: Se gestiona indirectamente a través del rol 
de Atención al Cliente. 
● Exploración de Productos Online (SOUP: PublicListingScreen y 
PublicBusinessProductsScreen): 
○ Pseudocódigo de Alto Nivel: 
// Frontend: PublicListingScreen.js 
FUNCION fetchPublicProducts(): 
productos = LLAMAR publicApi.getPublicProducts() 
MOSTRAR productos.map(p => p.nombre, p.precio_venta, p.cogs, 
p.margen_ganancia_real) 
// Frontend: PublicBusinessProductsScreen.js 
FUNCION fetchPublicBusinessProducts(businessId): 
negocio = LLAMAR publicApi.getPublicBusinessById(businessId) 
productos = LLAMAR publicApi.getPublicProductsByBusinessId(businessId) 
MOSTRAR negocio.nombre, negocio.descripcion 
MOSTRAR productos.map(p => p.nombre, p.precio_venta, p.cogs, 
p.margen_ganancia_real) 
○ Integración al Código Existente: Ya implementado en PublicListingScreen.js 
y PublicBusinessProductsScreen.js. 
Próximos Pasos del Capítulo 4 (Prioridad Alta) 
1. Implementar la Pantalla de Punto de Venta (POS) en el Frontend: 
○ Crear frontend/src/screens/SalePointScreen.js. 
○ Integrar la lógica para seleccionar productos, ajustar cantidades y registrar 
ventas. 
○ Añadir la ruta en frontend/src/App.js con renderizado condicional basado en 
la activación del panaderia_plugin. 
2. Añadir Campo stock_terminado al Modelo Producto en Backend: 
○ Modificar backend/app/models.py. 
○ Crear migración para añadir este campo. 
○ Actualizar backend/app/schemas.py y backend/app/crud/product.py para 
manejar este campo. 
3. Implementar Lógica de Descuento de Stock de Productos Terminados y de 
Insumos al Vender: 
○ Modificar backend/app/crud/product.py para que la función de registro de 
venta (o una nueva función) descuente stock_terminado del producto y 
cantidad_disponible de los insumos asociados. 
4. Actualizar ManageProductsScreen.js para mostrar COGS, Precio Sugerido, 
Margen Real y stock_terminado: 
○ Mejorar la visualización en la lista de productos del emprendedor. 
Funciones Avanzadas (Capítulos Posteriores) 
Las siguientes funcionalidades son importantes pero se posponen para capítulos 
futuros del roadmap: 
● Módulo de Encargos/Pedidos Online Completo: 
○ Modelos, esquemas, CRUDs y routers para Pedido y ItemPedido. 
○ Pantallas de CreateOrderScreen, ManageOrdersScreen, OrderDetailsScreen. 
○ Notificaciones para clientes y atención al cliente. 
● Módulo de Reportes Financieros Avanzados: 
○ Generación de reportes de ingresos, egresos, rentabilidad por períodos. 
○ Integración con datos de ventas y costos de insumos. 
● Sistema de Calificaciones y Reseñas: 
○ Modelos para Calificacion y Reseña. 
○ Lógica para calcular calificacion_promedio y total_calificaciones. 
○ Interfaz para clientes y visualización en productos/negocios. 
● Asistente de IA (Chatbot) Completo en Frontend: 
○ Implementación del componente de chatbot interactivo en 
PublicListingScreen. 
○ Manejo de la interfaz de usuario para las recomendaciones de la IA. 
● Gestión de Usuarios y Roles (Administración): 
○ Interfaz para que los dueños/managers asignen roles a sus empleados. 
● Integración con Pasarelas de Pago: 
○ Manejo de pagos electrónicos para pedidos online. 
● Gestión de Cadetes/Logística: 
○ Asignación y seguimiento de envíos a domicilio. 
4. Capítulo 5: Plugin Específico: "Actualización Discográfica" 
Prioridad: MEDIA (Se abordará después del Capítulo 4) 
Fecha de Inicio Estimada: Tras la finalización del Capítulo 4 
Objetivo: Adaptar y extender SOUP Market para satisfacer las necesidades operativas clave 
de un sello discográfico independiente, desde la gestión de stock y producción hasta la 
planificación de giras y contratos con artistas, bajo el nuevo protocolo de plugins. 
Visión General 
El plugin "Actualización Discográfica" permitirá a un sello discográfico independiente 
gestionar un catálogo de música (CDs, vinilos, cassettes) y merchandising, además 
de coordinar la carrera de sus artistas (contratos, giras). SOUP Market se adaptará 
para ser la plataforma central que permita a los sellos llevar un control detallado de 
sus activos físicos, planificar producciones, gestionar ventas y envíos, y sentar las 
bases para la gestión de relaciones con artistas y eventos. 
Roles y Funcionalidades Clave 
1.   Production/Inventory Manager (Usa SOUP Dashboard) 
Funciones Prioritarias: 
● Administrar Stock de Discos y Merch (SOUP: ManageProductsScreen, 
CreateProductScreen, EditProductScreen): 
○ Pseudocódigo de Alto Nivel: 
// Frontend: ManageProductsScreen.js 
FUNCION fetchCatalogItems(): 
items = LLAMAR productApi.getAllMyProducts() // Productos: Discos, 
Remeras, etc. 
MOSTRAR items.map(i => i.nombre, i.tipo_producto, i.stock_terminado, 
i.precio_venta) 
// Frontend: CreateProductScreen.js / EditProductScreen.js 
FUNCION handleSubmitCatalogItem(formData): 
// formData.tipo_producto podría ser 'disco_cd', 'disco_vinilo', 'remera', 
'sticker' 
// formData.stock_terminado: Cantidad actual en almacén 
LLAMAR productApi.createProduct(formData) O 
productApi.updateProduct(itemId, formData) 
○ Integración al Código Existente (Capítulo 5 - Prioridad Alta): 
■ Frontend: ManageProductsScreen.js, CreateProductScreen.js, 
EditProductScreen.js ya existen. Se adaptará la interfaz para que 
tipo_producto incluya opciones como "disco_cd", "disco_vinilo", "remera", 
"sticker", etc. El campo stock_terminado (introducido en Capítulo 4) será 
crucial aquí. Estos componentes se renderizarán condicionalmente si el 
plugin sello_discografico_plugin está activo. 
■ Backend: El ProductType enum en backend/app/models.py y schemas.py 
necesitará ser extendido para incluir estos nuevos tipos de productos. La 
lógica de CRUD para Producto ya soporta stock. 
● Planificar Nueva Producción a Fábricas (SOUP: ManageInsumosScreen / 
CreateInsumoScreen / EditInsumoScreen): 
○ Pseudocódigo de Alto Nivel: 
// Frontend: CreateInsumoScreen.js / EditInsumoScreen.js 
// Insumo podría representar el costo de producción de un lote o unidad en 
fábrica. 
FUNCION handleSubmitProductionCost(formData): 
// formData.nombre: "Costo Fabricación Vinilo Album X", 
formData.costo_unitario_compra: Costo por unidad 
LLAMAR insumoApi.createInsumo(formData) 
// Frontend: CreateProductScreen.js / EditProductScreen.js 
// Asociar "insumos" de producción al producto final (álbum/merch) 
FUNCION associateProductionCostToProduct(productId, 
productionInsumoId, unitsProduced): 
// Esto es similar a cómo los insumos se asocian a productos en panadería. 
// El "costo_unitario_compra" del insumo de producción contribuirá al 
COGS del producto final. 
○ Integración al Código Existente (Capítulo 5 - Prioridad Alta): 
■ Frontend: Se usarán las pantallas existentes de Insumos y Productos. La 
interpretación de "insumo" se extenderá para incluir costos de 
fabricación. 
■ Backend: No se requieren cambios estructurales significativos, solo una 
interpretación flexible de los datos existentes. 
2.   Sales & Logistics Coordinator (Usa SOUP Dashboard) 
Funciones Prioritarias: 
● Gestionar Encargos y Envíos de Productos (SOUP: SalePointScreen / 
ManageOrdersScreen): 
○ Pseudocódigo de Alto Nivel: 
// Frontend: SalePointScreen.js (adaptado para ventas directas/online) 
FUNCION recordSale(itemId, quantity, clientInfo, shippingAddress): 
LLAMAR backend.productApi.recordSale(itemId, quantity, 
usuarioLogueado.id) 
// Descontar stock_terminado 
// Registrar información de envío (futuro: módulo de pedidos) 
// Backend: crud/product.py (record_sale) 
// Ya implementado en Capítulo 4. Necesitará extenderse para manejar 
direcciones de envío. 
○ Integración al Código Existente (Capítulo 5 - Prioridad Alta): 
■ Frontend: La SalePointScreen.js (del Capítulo 4) se utilizará para registrar 
ventas. El Módulo de Encargos/Pedidos Online (futuro) será esencial 
para la gestión completa de envíos. 
■ Backend: La función record_sale ya existe. Se necesitará una extensión 
para asociar información de envío (cuando el módulo de pedidos esté 
listo). 
3.   Label Manager / Dueños (Usa SOUP Dashboard) 
Funciones Prioritarias: 
● Visión General Financiera (SOUP: DashboardScreen / ReportsScreen): 
○ Pseudocódigo de Alto Nivel: 
// Frontend: DashboardScreen.js 
FUNCION fetchLabelMetrics(): 
ventasTotales = LLAMAR salesApi.getTotalSales() 
cogsTotal = LLAMAR salesApi.getTotalCogs() 
margenGeneral = calculateMargin(ventasTotales, cogsTotal) 
MOSTRAR ventasTotales, cogsTotal, margenGeneral 
○ Integración al Código Existente (Capítulo 5 - Prioridad Alta): 
■ Frontend: DashboardScreen.js se actualizará para mostrar métricas 
financieras agregadas para el sello. 
■ Backend: Los datos de COGS y precio_venta de los productos (ya 
implementados) permitirán calcular estas métricas. 
Próximos Pasos del Capítulo 5 (Prioridad Alta) 
1. Extender ProductType Enum en Backend: 
○ Modificar backend/app/models.py y backend/app/schemas.py para incluir 
nuevos tipos como DISCO_CD, DISCO_VINILO, CASSETTE, REMERA, STICKER, 
BUZO, POSTER, etc. 
○ Crear migración para actualizar el enum en la base de datos. 
2. Adaptar Create/EditProductScreen.js para Nuevos Tipos de Producto: 
○ Asegurar que el Select de tipo_producto muestre las nuevas opciones 
relevantes para un sello discográfico. 
3. Implementar Campo stock_terminado y Lógica de Descuento (si no se 
completó en Capítulo 4): 
○ Esto es fundamental para la gestión de inventario de discos y merch. 
4. Adaptar SalePointScreen.js (del Capítulo 4) para Sello Discográfico: 
○ Asegurar que la interfaz de venta sea adecuada para vender discos y merch, 
descontando el stock_terminado. 
Funciones Avanzadas (Capítulos Posteriores) 
Las siguientes funcionalidades son importantes pero se posponen para capítulos 
futuros del roadmap: 
● Módulo de Contratos con Bandas: 
○ Modelos: Banda, Artista, Contrato (con campos para regalías, duración, etc.). 
○ Funcionalidad: Carga de documentos, seguimiento de fechas clave, cálculo 
de regalías. 
● Módulo de Planificación de Giras y Conciertos: 
○ Modelos: Gira, Concierto, FechaConcierto (con campos para lugar, fecha, 
hora, presupuesto, ventas de entradas). 
○ Funcionalidad: Gestión de logística, seguimiento de gastos por concierto, 
integración con artistas. 
● Módulo de Encargos/Pedidos Online Completo: 
○ Gestión de direcciones de envío, integración con transportistas, seguimiento 
de pedidos. (Ya mencionado en Capítulo 4, pero más crítico aquí para ventas 
online globales). 
● Módulo de Reportes Financieros Avanzados: 
○ Reportes específicos para sellos (ventas por artista, por formato, por tour). 
● Módulo de Distribución Digital: 
○ Integración con plataformas de streaming y descarga. 
● Gestión de Promoción y Marketing: 
○ Seguimiento de campañas de prensa, radio, redes sociales por lanzamiento. 
5. Instrucciones de Implementación para Cursor 
Basado en la descripción detallada de este documento, tu tarea es comenzar a 
implementar el Protocolo de Actualizaciones y Plugins y los plugins 
"Actualización Panadería" y "Actualización Discográfica". 
1. Determinación de Archivos: Tú eres responsable de determinar qué archivos 
existentes deben ser modificados (ej., models.py, schemas.py, App.js, 
DashboardScreen.js, CreateProductScreen.js, EditProductScreen.js, etc.) y qué 
nuevos archivos deben ser creados (ej., routers/plugin_router.py, crud/plugin.py, 
SalePointScreen.js, PluginMarketplaceScreen.js). 
2. Priorización del Roadmap: 
○ Primero: Prioriza la implementación de los "Próximos Pasos" definidos en el 
Capítulo 3 (Protocolo de Plugins). Esto sentará las bases para la 
arquitectura modular. 
○ Segundo: Una vez que la base del protocolo esté en su lugar, procede con la 
implementación de los "Próximos Pasos" del Capítulo 4 (Plugin 
'Actualización Panadería'). 
○ Tercero: Finalmente, implementa los "Próximos Pasos" del Capítulo 5 
(Plugin 'Actualización Discográfica'). 
3. Pseudocódigo como Guía: Utiliza el pseudocódigo de alto nivel proporcionado 
en cada sección como una guía para la lógica de las funciones. 
4. No Repetir Código (DRY): Asegúrate de reutilizar al máximo los componentes, 
modelos y lógicas existentes de la aplicación core. 
5. Documentación de Cambios: 
○ Durante la implementación: Mantén un registro de todos los archivos que 
modificas o creas. 
○ Después de la implementación: Deberás actualizar la 
DOCUMENTACION_TECNICA.md (para reflejar los cambios en modelos, 
esquemas, rutas, etc. y el progreso de los capítulos del roadmap) y el 
HISTORIAL_DE_BUGS.md (si surge algún problema durante la 
implementación). 
Por favor, comienza con la implementación del Protocolo de Plugins y luego los 
plugins 'Actualización Panadería' y 'Actualización Discográfica' según las 
prioridades establecidas. Proporciona el código de los archivos a medida que 
los vayas modificando o creando. 